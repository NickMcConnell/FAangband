#ifndef INCLUDED_DEFINES_H
#define INCLUDED_DEFINES_H

/** \file defines.h 
    \brief Constant, flag and macro definitions 

 * Version #, grid, etc. size, MAX_* figures, limits, constants, critical
 * values, etc. for every characteristic of Angband.  Indexes, text locat-
 * ions, list of summonable monsters. Feature, artifact and ego-item codes.
 * Object tval (kind) and sval (specific type) with sval limitations.
 * Monster blow constants, function, player, object and monster bit flags
 * (translation from code to flag).  Definitions of options and object in-
 * scriptions.
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This software may be copied and distributed for educational, research,
 * and not for profit purposes provided that this copyright and statement
 * are included in all such copies.  Other copyrights may also apply.
 *


 *
 * Do not edit this file unless you know *exactly* what you are doing.
 * 
 * Some of the values in this file were chosen to preserve game balance,
 * while others are hard-coded based on the format of old save-files, the
 * definition of arrays in various places, mathematical properties, fast
 * computation, storage limits, or the format of external text files.
 *
 * Changing some of these values will induce crashes or memory errors or
 * savefile mis-reads.  Most of the comments in this file are meant as
 * reminders, not complete descriptions, and even a complete knowledge
 * of the source may not be sufficient to fully understand the effects
 * of changing certain definitions.
 *
 * Lastly, note that the code does not always use the symbolic constants
 * below, and sometimes uses various hard-coded values that may not even
 * be defined in this file, but which may be related to definitions here.
 * This is of course bad programming practice, but nobody is perfect...
 *
 * For example, there are MANY things that depend on the screen being
 * 80x24, with the top line used for messages, the bottom line being
 * used for status, and exactly 22 lines used to show the dungeon.
 * Just because your screen can hold 46 lines does not mean that the
 * game will work if you try to use 44 lines to show the dungeon.
 *
 * You have been warned.
 */

/* Hack */
#include "tvalsval.h"

/**
 * Name of the version/variant
 */
#define SAVEFILE_NAME  "FAAN"


/**
 * Current version string - according to FAangband reckoning.
 */
/*
#ifdef BUILD_ID
#define VERSION_STRING	"1.3.3 (" BUILD_ID ")"
#endif
*/

/*
 * Current FAangband version numbers.
 */
#define VERSION_MAJOR	1
#define VERSION_MINOR	3
#define VERSION_PATCH	3
#define VERSION_EXTRA	0

/**
 * Number of grids in each block (vertically)
 * Probably hard-coded to 11, see "generate.c"
 */
#define BLOCK_HGT	11

/**
 * Number of grids in each block (horizontally)
 * Probably hard-coded to 11, see "generate.c"
 */
#define BLOCK_WID	11


/**
 * Number of grids in each panel (vertically)
 */
#define PANEL_HGT	((int)(BLOCK_HGT / tile_height))

/**
 * Number of grids in each panel (horizontally)
 */
#define PANEL_WID       ((int)(BLOCK_WID / tile_width))


/**
 * Number of text rows in each map screen, regardless of tile size
 */
#define SCREEN_ROWS	(Term->hgt - ROW_MAP  - 1) 

/**
 * Number of grids in each screen (vertically)
 */
#define SCREEN_HGT    ((int) (SCREEN_ROWS / tile_height))

/**
 * Number of grids in each screen (horizontally)
 */
#define SCREEN_WID	((int)((Term->wid - COL_MAP - 1) / tile_width))

#define ROW_MAP			1
#define COL_MAP			13

/**
 * Number of grids in each dungeon (from top to bottom)
 * Must be a multiple of SCREEN_HGT
 * Must be less or equal to 256
 */
#define DUNGEON_HGT		66

/**
 * Number of grids in each dungeon (from left to right)
 * Must be a multiple of SCREEN_WID
 * Must be less or equal to 256
 */
#define DUNGEON_WID		198

/*
 * Radii for various detection spells. -BR-
 */
#define DETECT_RAD_DEFAULT      30
#define DETECT_RAD_MAP          255

/* 
 * Hard line maxima for char_attr lines 
 */
#define MAX_C_A_LEN 80
#define MAX_C_A_SML 48

/**
 * Maximum amount of Angband windows.
 */
#define ANGBAND_TERM_MAX 8


/**
 * Total number of towns 
 */
#define NUM_TOWNS       10

/**
 * Number of small towns 
 */
#define NUM_TOWNS_SMALL  6

/**
 * Number of large towns 
 */
#define NUM_TOWNS_BIG    4

/**
 * Total number of stores (see "store.c", etc)
 */
#define MAX_STORES       60

/**
 * Number of stores in a large town (see "store.c", etc)
 */
#define MAX_STORES_BIG    9

/**
 * Number of stores in a small town (see "store.c", etc)
 */
#define MAX_STORES_SMALL  4

/**
 * Number of store types
 */
#define MAX_STORE_TYPES  10

/*
 * Store numbers
 */
#define STORE_GEN 		0
#define STORE_ARMORY 		1
#define STORE_WEAPON 		2
#define STORE_TEMPLE 		3
#define STORE_ALCH 		4
#define STORE_MAGIC 		5
#define STORE_BLACKM 		6
#define STORE_HOME 		7
#define STORE_BOOK 		8
#define STORE_MERCH             9

/**
 * Map modes
 */
#define MAP_COMPRESSED     0
#define MAP_EXTENDED       1
#define MAP_DUNGEON        2
#define MAP_FANILLA        3
#define MAP_MAX            4

/**
 * Game modes
 */
enum
{
    GAME_MODE_THRALL = 0,
    GAME_MODE_IRONMAN,
    GAME_MODE_NO_STAIRS,
    GAME_MODE_SMALL_DEVICE,
    GAME_MODE_NO_ARTIFACTS,
    GAME_MODE_NO_SELLING,
    GAME_MODE_AI_CHEAT,

    GAME_MODE_MAX
};

#define MODE(gmode)	p_ptr->game_mode[GAME_MODE_##gmode]

/**
 * Maximum number of player "sex" types (see "table.c", etc)
 */
#define MAX_SEXES            2

/**
 * Maximum amount of starting equipment
 */
#define MAX_START_ITEMS	4
#define STARTING_GOLD 600

/**
 * Maximum number of specialty abilities for a single character
 */
#define MAX_SPECIALTIES      10

/**
 * Number of specialty abilities available to a character class
 */
#define CLASS_SPECIALTIES      15

/*
 * Hack -- first normal and random artifact in the artifact list.  
 * All of the artifacts with indexes from 1 to 22 are special (lights, 
 * rings, amulets), the ones from 23 to 209 are normal, and the ones from 
 * 210 to 249 are random.
 */
#define ART_MIN_NORMAL		23
#define ART_MIN_RANDOM		210

/*
 * Number of tval/min-sval/max-sval slots per ego_item
 */
#define EGO_TVALS_MAX 3

/**
 * Hack -- Maximum number of quests
 */
#define MAX_Q_IDX	5

/**
 * Maximum number of high scores in the high score file
 */
#define MAX_HISCORES	100


/**
 * Maximum dungeon level.  The player can never reach this level
 * in the dungeon, and this value is used for various calculations
 * involving object and monster creation.  It must be at least 100.
 * Setting it below 128 may prevent the creation of some objects.
 */
#define MAX_DEPTH	128


/**
 * Maximum number of paths from a wilderness stage to adjoining stages.
 */
#define MAX_PATHS       13


/**
 * Number of recall points the player can set
 */
#define MAX_RECALL_PTS   4

/**
 * Number of stages.  The relationship between individual stages is defined
 * in the stage_map array in tables.c.     -NRM-
 */
#define NUM_STAGES      412

/**
 * Maximum size of the "view" array (see "cave.c")
 * Note that the "view radius" will NEVER exceed 20, and even if the "view"
 * was octagonal, we would never require more than 1520 entries in the array.
 */
#define VIEW_MAX 1536

/**
 * Maximum size of the "temp" array (see "cave.c")
 * Note that we must be as large as "VIEW_MAX" for proper functioning
 * of the "update_view()" function, and we must also be as large as the
 * largest illuminatable room, but no room is larger than 800 grids.  We
 * must also be large enough to allow "good enough" use as a circular queue,
 * to calculate monster flow, but note that the flow code is "paranoid".
 */
#define TEMP_MAX 1536

/**
 * Maximum distance from the character to store flow (noise) information
 */
#define NOISE_STRENGTH 45

/**
 * Character turns it takes for smell to totally dissipate
 */
#define SMELL_STRENGTH 60

/**
 * OPTION: Maximum number of "quarks" (see "io.c")
 * Default: assume at most 512 different inscriptions are used
 */
#define QUARK_MAX	512

/**
 * OPTION: Maximum number of autoinscriptions(see "object1.c")
 */
#define AUTOINSCRIPTIONS_MAX 216

/**
 * OPTION: Maximum number of messages to remember (see "io.c")
 * Default: assume maximal memorization of 2048 total messages
 */
#define MESSAGE_MAX	2048

/**
 * OPTION: Maximum space for the message text buffer (see "io.c")
 * Default: assume that each of the 2048 messages is repeated an
 * average of three times, and has an average length of 48
 */
#define MESSAGE_BUF	32768

/**
 * Defines for graphics mode
 */

#define GRAPHICS_NONE           0


/* player_type.noscore flags */
#define NOSCORE_WIZARD		0x0002
#define NOSCORE_DEBUG		0x0008
#define NOSCORE_BORG		0x0010

/* History message types */
#define HISTORY_PLAYER_BIRTH     0x0001	/* Player was born */
#define HISTORY_ARTIFACT_UNKNOWN 0x0002	/* Player found unknown artifact */
#define HISTORY_ARTIFACT_KNOWN   0x0004	/* Player has IDed an artifact */
#define HISTORY_ARTIFACT_LOST    0x0008	/* Player had an artifact and lost it */
#define HISTORY_PLAYER_DEATH     0x0010	/* Player has been slain */
#define HISTORY_SLAY_UNIQUE      0x0020	/* Player has slain a unique monster */
#define HISTORY_USER_INPUT       0x0040	/* User-added note */
#define HISTORY_MOVE_HOUSE       0x0080	/* PLayer moved house */
#define HISTORY_GAIN_LEVEL       0x0100	/* Player gained a level */
#define HISTORY_GAIN_SPECIALTY   0x0200	/* Player gained a specialty */

/**
 * List of commands that will be auto-repeated
 *
 * ToDo: This string should be user-configurable.
 */
#define AUTO_REPEAT_COMMANDS "TBDoc+"


/** 
 * Given an array, determine how many elements are in the array.
 */
#define N_ELEMENTS(a) (sizeof(a) / sizeof((a)[0]))


/**
 * Maximum value storable in a "byte" (hard-coded)

 #define MAX_UCHAR       255 */

/**
 * Maximum value storable in a "s16b" (hard-coded)
 
 #define MAX_SHORT       32767 */



/*** FAangband Themed Levels ***/

/**
 * No current theme (player is on a normal level)
 */
#define THEME_NONE		0

/*
 * Themed level indices.  Used to activate any theme-specific code. 
 * See generate.c for the table of themed level information.
 */
#define THEME_ELEMENTAL		1
#define THEME_DRAGON		2
#define THEME_WILDERNESS	3
#define THEME_DEMON		4
#define THEME_MINE		5
#define THEME_WARLORDS		6
#define THEME_AELUIN            7
#define THEME_ESTOLAD           8
#define THEME_SLAIN             9

/**
 * Current number of defined themes.  The maximum theoretical number is 32.
 */
#define THEME_MAX		9


/*
 * Store constants
 */
#define STORE_INVEN_MAX	24	/* Max number of discrete objs in inven */
#define STORE_CHOICES	32	/* Number of items to choose stock from */
#define STORE_OBJ_LEVEL	5	/* Magic Level for normal stores */
#define STORE_TURNOVER	9	/* Normal shop turnover, per day */
#define STORE_MIN_KEEP	6	/* Min slots to "always" keep full */
#define STORE_MAX_KEEP	18	/* Max slots to "always" keep full */
#define STORE_SHUFFLE	20	/* 1/Chance (per day) of an owner changing */
#define STORE_TURNS	1000	/* Number of turns between turnovers */


/*
 * Misc constants
 */
#define TOWN_DAWN	2000	/* Number of turns from dawn to dawn XXX */
#define BREAK_GLYPH	300	/* Rune of protection resistance */
#define BTH_PLUS_ADJ    1       /* Adjust BTH per plus-to-hit */
#define MON_MULT_ADJ	8	/* High value slows multiplication */
#define MON_SUMMON_ADJ	2	/* Adjust level of summoned creatures */
#define MON_DRAIN_LIFE	2	/* Percent of player exp drained per hit */
#define USE_DEVICE      3	/* x> Harder devices x< Easier devices     */

/**
 * Percentage likelihood that monsters will be disturbed by the
 * character each ten game turns, assuming a stealth of zero.
 *
 * This value is 100 in Angband.  It has been lowered in Oangband because
 * combat and other actions can temporarily increase the noise level.
 */
#define WAKEUP_ADJ    90


/**
 * There is a 1/40 (2.5%) chance of inflating the requested object_level
 * during the creation of an object (see "get_obj_num()" in "object.c").
 * Lower values yield better objects more often.
 */
#define GREAT_OBJ	40

/**
 * There is a 1/25 (4%) chance that ego-items with an inflated base-level are
 * generated when an object is turned into an ego-item (see make_ego_item()
 * in object2.c). As above, lower values yield better ego-items more often.
 */
#define GREAT_EGO	25

/**
 * There is a 1/25 (4%) chance of inflating the requested monster_level
 * during the creation of a monsters (see "get_mon_num()" in "monster2.c").
 * Lower values yield harder monsters more often.  Value raised in FAangband.
 */
#define NASTY_MON	25	/** 1/chance of inflated monster level */

/**
 * Fraction of turns in which the extend magic special ability causes timers to
 * not decrement.
 */
#define EXTEND_MAGIC_FRACTION  3 /* Skip 3rd turn -> 50% longer durations */

/**
 * Amount of mana removed by Mana Burn specialty.
 */
#define BASE_MANA_BURN          20

/*
 * Refueling constants
 */
#define FUEL_TORCH	5000	/* Maximum amount of fuel in a torch */
#define FUEL_LAMP	15000   /* Maximum amount of fuel in a lantern */


/*
 * More maximum values
 */
#define MAX_SIGHT_LGE   20      /* Maximum view distance */
#define MAX_RANGE_LGE   20      /* Maximum projection range */
#define MAX_SIGHT_SML   10      /* Maximum view distance (small devices) */
#define MAX_RANGE_SML   10      /* Maximum projection range (small devices) */
#define MAX_SIGHT (MODE(SMALL_DEVICE) ? MAX_SIGHT_SML : MAX_SIGHT_LGE)  
#define MAX_RANGE (MODE(SMALL_DEVICE) ? MAX_RANGE_SML : MAX_RANGE_LGE)


/**
 * There is a 1/160 chance per round of creating a new monster
 */
#define MAX_M_ALLOC_CHANCE	160

/**
 * Normal levels get at least 16 monsters
 */
#define MIN_M_ALLOC_LEVEL	16

/**
 * The town starts out with 4 residents during the day
 */
#define MIN_M_ALLOC_TD		4

/**
 * The town starts out with 8 residents during the night
 */
#define MIN_M_ALLOC_TN		8


/**
 * A monster can only "multiply" (reproduce) if there are fewer than 100
 * monsters on the level capable of such spontaneous reproduction.  This
 * is a hack which prevents the "m_list[]" array from exploding due to
 * reproducing monsters.  Messy, but necessary.
 */
#define MAX_REPRO	100

/** 
 * Special player ghost slot in lib/edit/monster.txt 
 */
#define PLAYER_GHOST_RACE       799


/*
 * Player constants
 */
#define PY_MAX_EXP	99999999L	/* Maximum exp */
#define PY_MAX_GOLD	99999999L	/* Maximum gold */
#define PY_MAX_LEVEL	50		/* Maximum level */
#define PY_MAX_SPELLS   64              /* Maximum number of spells */
#define PY_MAX_BOOKS    11              /* Maximum number of spellbooks */


/*
 * Flags for player_type.spell_flags[]
 */
#define PY_SPELL_LEARNED    0x01 /* Spell has been learned */
#define PY_SPELL_WORKED     0x02 /* Spell has been successfully tried */
#define PY_SPELL_FORGOTTEN  0x04 /* Spell has been forgotten */

/*
 * Player "food" crucial values
 */
#define PY_FOOD_UPPER   20000   /* Upper limit on food counter */
#define PY_FOOD_MAX	15000	/* Food value (Bloated) */
#define PY_FOOD_FULL	10000	/* Food value (Normal) */
#define PY_FOOD_ALERT	2000	/* Food value (Hungry) */
#define PY_FOOD_WEAK	1000	/* Food value (Weak) */
#define PY_FOOD_FAINT	500	/* Food value (Fainting) */
#define PY_FOOD_STARVE	100	/* Food value (Starving) */

/*
 * Player regeneration constants
 */
#define PY_REGEN_NORMAL		197	/* Regen factor*2^16 when full */
#define PY_REGEN_WEAK		98	/* Regen factor*2^16 when weak */
#define PY_REGEN_FAINT		33	/* Regen factor*2^16 when fainting */
#define PY_REGEN_HPBASE		1442	/* Min amount hp regen*2^16 */
#define PY_REGEN_MNBASE		524	/* Min amount mana regen*2^16 */


/** Maximum number of blow types available to Druids. -LM- */
#define NUM_D_BLOWS		20


/**
 * Maximum number of "normal" pack slots, and the index of the "overflow"
 * slot, which can hold an item, but only temporarily, since it causes the
 * pack to "overflow", dropping the "last" item onto the ground.  Since this
 * value is used as an actual slot, it must be less than "INVEN_WIELD" (below).
 * Note that "INVEN_PACK" is probably hard-coded by its use in savefiles, and
 * by the fact that the screen can only show 23 items plus a one-line prompt.
 */
#define INVEN_PACK		23 

/**
 * Like the previous but takes into account the (variably full quiver).
 */
#define INVEN_MAX_PACK  (INVEN_PACK - p_ptr->quiver_slots)

/*
 * Indexes used for various "equipment" slots (hard-coded by savefiles, etc).
 */
#define INVEN_WIELD	24
#define INVEN_BOW       25
#define INVEN_LEFT      26
#define INVEN_RIGHT     27
#define INVEN_NECK      28
#define INVEN_LIGHT      29
#define INVEN_BODY      30
#define INVEN_OUTER     31
#define INVEN_ARM       32
#define INVEN_HEAD      33
#define INVEN_HANDS     34
#define INVEN_FEET      35

#define INVEN_TOTAL	36

/**
 *Quiver
 */
#define QUIVER_START 37
#define QUIVER_SIZE  10
#define QUIVER_END   47

/**
 * Each throwing weapon in the "quiver" takes up the space of this
 * many pieces of ammo. 
 */
#define THROWER_AMMO_FACTOR 5

/**
 * The number of ammo equivalents per quiver slot
 */
#define QUIVER_SLOT_SIZE    99

/**
 * Total number of inventory slots (hard-coded to be <= 47).
 */
#define ALL_INVEN_TOTAL	47

/**
 * Special 'Item' Identifier corresponding to all Squelched items.
 */
#define ALL_SQUELCHED   101


/**
 * A "stack" of items is limited to less than 100 items (hard-coded).
 */
#define MAX_STACK_SIZE	100



/**
 * An item's pval (for charges, amount of gold, etc) is limited to s16b
 */
#define MAX_PVAL  32767

/**
 * Maximum number of objects allowed in a single dungeon grid.
 *
 * The main-screen has a minimum size of 24 rows, so we can always
 * display 23 objects + 1 header line.
 */
#define MAX_FLOOR_STACK			23

/*** Constants for accessing the player struct ***/

/*
 * Timed effects
 */
enum
{
	TMD_FAST = 0, 
	TMD_SLOW, 
	TMD_BLIND, 
	TMD_PARALYZED, 
	TMD_CONFUSED,
	TMD_AFRAID, 
	TMD_IMAGE, 
	TMD_POISONED, 
	TMD_CUT, 
	TMD_STUN, 
	TMD_PROTEVIL,
	TMD_INVULN, 
	TMD_HERO, 
	TMD_SHERO, 
	TMD_SHIELD, 
	TMD_BLESSED, 
	TMD_SINVIS,
	TMD_SINFRA, 
	TMD_TELEPATHY, 
	TMD_SSTEALTH,
	TMD_OPP_ACID, 
	TMD_OPP_ELEC, 
	TMD_OPP_FIRE, 
	TMD_OPP_COLD,
	TMD_OPP_POIS, 
	TMD_ATT_ACID,
	TMD_ATT_ELEC,
	TMD_ATT_FIRE,
	TMD_ATT_COLD,
	TMD_ATT_POIS,

	TMD_MAX
};

/*
 * Skill indexes
 */
enum
{
	SKILL_DISARM,			/* Skill: Disarming */
	SKILL_DEVICE,			/* Skill: Magic Devices */
	SKILL_SAVE,			/* Skill: Saving throw */
	SKILL_STEALTH,			/* Skill: Stealth factor */
	SKILL_SEARCH,			/* Skill: Searching ability */
	SKILL_SEARCH_FREQUENCY,	        /* Skill: Searching frequency */
	SKILL_TO_HIT_MELEE,		/* Skill: To hit (normal) */
	SKILL_TO_HIT_BOW,		/* Skill: To hit (shooting) */
	SKILL_TO_HIT_THROW,		/* Skill: To hit (throwing) */
	SKILL_DIGGING,			/* Skill: Digging */

	SKILL_MAX
};


/*
 * Indexes of the various "stats" (hard-coded by savefiles, etc).
 */
enum
{
	A_STR = 0,
	A_INT,
	A_WIS,
	A_DEX,
	A_CON,
	A_CHR,

	A_MAX
};



/*
 * The range of possible indexes into tables based upon stats.
 * Currently things range from 3 to 18/220 = 40.
 */
#define STAT_RANGE 38


/*
 * Player sex constants (hard-coded by save-files, arrays, etc)
 */
#define SEX_FEMALE	0
#define SEX_MALE		1

/*
 * Player class constants (hard-coded by save-files, arrays, etc)
 */
enum
{
    CLASS_WARRIOR = 0,
    CLASS_MAGE,	
    CLASS_PRIEST,	
    CLASS_ROGUE,	
    CLASS_RANGER,	
    CLASS_PALADIN,	
    CLASS_DRUID,	
    CLASS_NECRO,	
    CLASS_ASSASSIN,

    CLASS_MAX
};	

/* Different realms here.  From Sangband */
enum
{
    REALM_NONE = 0,
    REALM_SORCERY,		
    REALM_PIETY,		
    REALM_NATURE,		
    REALM_NECROMANTIC,

    REALM_MAX
};	

/* Values for accessing the magic description array */
enum
{
    SPELL_NOUN = 0,
    SPELL_VERB,
    SPELL_FAIL,
    BOOK_NOUN,
    BOOK_LACK,

    MD_MAX
};

/* 
 * Special values for the number of turns to rest, these need to be
 * negative numbers, as postive numbers are taken to be a turncount,
 * and zero means "not resting". 
 */
enum 
{
	REST_COMPLETE = -2,
	REST_ALL_POINTS = -1,
	REST_SUNLIGHT = -3
};

/*** General index values ***/


/*
 * Legal restrictions for "summon_specific()"
 */
#define SUMMON_KIN		 1
#define SUMMON_SAURON            2
#define SUMMON_ANT		11
#define SUMMON_SPIDER		12
#define SUMMON_HOUND		13
#define SUMMON_ANIMAL		14
#define SUMMON_SWAMP     	15
#define SUMMON_DEMON		16
#define SUMMON_UNDEAD		17
#define SUMMON_DRAGON		18
#define SUMMON_HI_DEMON		20
#define SUMMON_HI_UNDEAD	21
#define SUMMON_HI_DRAGON	22
#define SUMMON_WRAITH		31 /* now unused */
#define SUMMON_UNIQUE		32
#define SUMMON_ELEMENTAL	33
#define SUMMON_VORTEX		34
#define SUMMON_HYBRID		35
#define SUMMON_BIRD		36
#define SUMMON_GOLEM            37
#define SUMMON_THIEF		38


/*
 * Indexes for array of player incremental resists.
 */
#define P_RES_ACID		0
#define P_RES_ELEC		1
#define P_RES_FIRE		2
#define P_RES_COLD		3
#define P_RES_POIS		4
#define P_RES_LIGHT		5
#define P_RES_DARK		6
#define P_RES_CONFU		7
#define P_RES_SOUND		8
#define P_RES_SHARD		9
#define P_RES_NEXUS		10
#define P_RES_NETHR		11
#define P_RES_CHAOS		12
#define P_RES_DISEN		13
#define MAX_P_RES		14

/*
 * Indexes for array of player non-stat bonuses.
 */
#define P_BONUS_M_MASTERY       0
#define P_BONUS_STEALTH         1
#define P_BONUS_SEARCH          2
#define P_BONUS_INFRA           3
#define P_BONUS_TUNNEL          4
#define P_BONUS_SPEED           5
#define P_BONUS_SHOTS           6
#define P_BONUS_MIGHT           7
#define MAX_P_BONUS             8

/*
 * Indexes for array of player slay multiples.
 */
#define P_SLAY_ANIMAL           0
#define P_SLAY_EVIL             1
#define P_SLAY_UNDEAD           2
#define P_SLAY_DEMON            3
#define P_SLAY_ORC              4
#define P_SLAY_TROLL            5
#define P_SLAY_GIANT            6
#define P_SLAY_DRAGON           7
#define MAX_P_SLAY              8

/*
 * Indexes for array of player brand multiples.
 */
#define P_BRAND_ACID            0
#define P_BRAND_ELEC            1
#define P_BRAND_FIRE            2
#define P_BRAND_COLD            3
#define P_BRAND_POIS            4
#define MAX_P_BRAND             5

/*
 * Resistance limits - the number really means percentage damage taken -NRM-.
 */
#define RES_LEVEL_BASE		100
#define RES_LEVEL_MAX		200
#define RES_LEVEL_MIN		0

/*
 * Incremental resistance modifiers and caps.
 */
#define RES_BOOST_NORMAL	60
#define RES_BOOST_GREAT		45
#define RES_BOOST_IMMUNE	0
#define RES_BOOST_MINOR		75
#define RES_CUT_MINOR           130
#define RES_CUT_NORMAL          150
#define RES_CUT_GREAT           180
#define RES_CAP_EXTREME		75
#define RES_CAP_MODERATE	40
#define RES_CAP_ITEM            20

/* Defaults and modifiers for bonuses and multiples */
#define BONUS_BASE              0
#define MULTIPLE_BASE           10
#define SLAY_BOOST_SMALL        15  /* Slay Evil */
#define SLAY_BOOST_MINOR        17  /* Slay Animal */
#define SLAY_BOOST_NORMAL       20  /* Regular Slay */
#define SLAY_BOOST_KILL         25  /* Slay Kill */
#define BRAND_BOOST_NORMAL      17  /* Regular Brand */

/*
 * Some qualitative checks.
 */
#define p_resist_pos(X) \
   (p_ptr->state.res_list[X] < 100)
#define p_resist_good(X) \
   (p_ptr->state.res_list[X] <= 80)
#define p_resist_strong(X) \
   (p_ptr->state.res_list[X] <= 20)
#define p_immune(X) \
   (p_ptr->state.res_list[X] == 0)
#define p_vulnerable(X) \
   (p_ptr->state.res_list[X] > 100)

#define k_resist_pos(X) \
   (p_ptr->state.dis_res_list[X] < 100)
#define k_resist_good(X) \
   (p_ptr->state.dis_res_list[X] <= 80)
#define k_resist_strong(X) \
   (p_ptr->state.dis_res_list[X] <= 20)
#define k_immune(X) \
   (p_ptr->state.dis_res_list[X] == 0)
#define k_vulnerable(X) \
   (p_ptr->state.dis_res_list[X] > 100)

#define o_slay_weak(X, Y) \
   (X->multiple_slay[Y] < 10)
#define o_slay(X, Y) \
   (X->multiple_slay[Y] > 10)
#define o_kill(X, Y) \
   (X->multiple_slay[Y] > 20)

#define o_brand(X, Y) \
   (X->multiple_brand[Y] > 10)

/*
 * Some constants for the "learn" code.  These generalized from the
 * old DRS constants.
 */
#define LRN_FREE_SAVE	14
#define LRN_MANA	15
#define LRN_ACID	16
#define LRN_ELEC	17
#define LRN_FIRE	18
#define LRN_COLD	19
#define LRN_POIS	20
#define LRN_FEAR_SAVE	21
#define LRN_LIGHT	22
#define LRN_DARK	23
#define LRN_BLIND	24
#define LRN_CONFU	25
#define LRN_SOUND	26
#define LRN_SHARD	27
#define LRN_NEXUS	28
#define LRN_NETHR	29
#define LRN_CHAOS	30
#define LRN_DISEN	31
/* new in Oangband 0.5 and beyond */
#define LRN_DFIRE	38
#define LRN_SAVE        39
#define LRN_ARCH        40
#define LRN_PARCH       41
#define LRN_ICE         42
#define LRN_PLAS        43
#define LRN_SOUND2      44 /* attacks which aren't resisted, 
			    * but res sound prevent stun */
#define LRN_STORM       45
#define LRN_WATER       46
#define LRN_NEXUS_SAVE  47 /* Both resist Nexus and Saves apply */
#define LRN_BLIND_SAVE  48 /* Both resist Blind and Saves apply */
#define LRN_CONFU_SAVE  49 /* Both resist Confusion and Saves apply */
#define LRN_ALL         50 /* Recurses to all the resistables */

/*** Feature Indexes (see "lib/edit/terrain.txt") ***/

/** Nothing */
#define FEAT_NONE	0x00

/* Various */
#define FEAT_FLOOR	0x01
#define FEAT_INVIS	0x02
#define FEAT_OPEN	0x03
#define FEAT_BROKEN	0x04
#define FEAT_MORE	0x05
#define FEAT_LESS	0x06
#define FEAT_MORE_SHAFT	0x07
#define FEAT_LESS_SHAFT	0x08

/* Doors */
#define FEAT_DOOR_HEAD	0x20
#define FEAT_DOOR_TAIL	0x2F

/* Extra */
#define FEAT_SECRET	0x30
#define FEAT_RUBBLE	0x31

/* Seams */
#define FEAT_MAGMA	0x32
#define FEAT_QUARTZ	0x33
#define FEAT_MAGMA_H	0x34
#define FEAT_QUARTZ_H	0x35
#define FEAT_MAGMA_K	0x36
#define FEAT_QUARTZ_K	0x37

/* Walls */
#define FEAT_WALL_EXTRA	0x38
#define FEAT_WALL_INNER	0x39
#define FEAT_WALL_OUTER	0x3A
#define FEAT_WALL_SOLID	0x3B
#define FEAT_PERM_EXTRA	0x3C
#define FEAT_PERM_INNER	0x3D
#define FEAT_PERM_OUTER	0x3E
#define FEAT_PERM_SOLID	0x3F

/*
 * Oangband shops are moved to 0x40 to 0x48 to make room for
 * the extra bookstore.  Method borrowed from Zangband. -LM-
 * Nother one. -NRM-
 */
#define FEAT_SHOP_HEAD 0x40
#define FEAT_SHOP_HOME 0x47
#define FEAT_SHOP_TAIL 0x49

/* "stairs" in wilderness -NRM- */
#define FEAT_LESS_NORTH		0x60
#define FEAT_MORE_NORTH		0x61
#define FEAT_LESS_EAST		0x62
#define FEAT_MORE_EAST		0x63
#define FEAT_LESS_SOUTH		0x64
#define FEAT_MORE_SOUTH		0x65
#define FEAT_LESS_WEST		0x66
#define FEAT_MORE_WEST		0x67

/* Special dungeon/wilderness features. -LM- Expanded for FAangband 0.3.4 */
#define FEAT_MIN_SPECIAL        0x70
#define FEAT_LAVA		0x70
#define FEAT_WATER      	0x71
#define FEAT_TREE               0x72
#define FEAT_TREE2		0x73
#define FEAT_GRASS              0x74  
#define FEAT_ROAD               0x75
#define FEAT_VOID               0x77  
#define FEAT_PIT                0x78  
#define FEAT_DUNE               0x7a

/*** Trap Indexes (see "lib/edit/trap.txt") ***/

/** Nothing */
#define TRAP_NONE	0x00

/* Runes  */
#define RUNE_HEAD       0x01
#define RUNE_TAIL       0x07
#define RUNE_ELEMENTS   0x01
#define RUNE_MAGDEF     0x02
#define RUNE_QUAKE      0x03
#define RUNE_MANA       0x04
#define RUNE_PROTECT    0x05
#define RUNE_POWER      0x06
#define RUNE_SPEED      0x07

/* Other obstructions */
#define OBST_WEB        0x0A

/* Traps */
#define TRAP_HEAD	0x10
#define TRAP_TAIL	0x1F
#define TRAP_TRAPDOOR	0x10
#define TRAP_PIT	0x11
#define TRAP_DART	0x12
#define TRAP_SPOT	0x13
#define TRAP_GAS	0x14
#define TRAP_SUMMON	0x15
#define TRAP_ALTER	0x16
#define TRAP_HEX	0x17
#define TRAP_PORTAL	0x18
#define TRAP_MURDER	0x19
#define TRAP_BRANCH	0x1A

/* Specials trap that only effects monsters.  Created only by rogues. -LM- */
#define MTRAP_HEAD		0x40
#define MTRAP_TAIL		0x4F
#define MTRAP_BASE		0x40 /* Level 1 */
#define MTRAP_STURDY    	0x41 /* Level 1 */
#define MTRAP_NET		0x42 /* Level 6 */
#define MTRAP_CONF		0x43 /* Level 12 */
#define MTRAP_POISON	        0x44 /* Level 18 */
#define MTRAP_SPIRIT	        0x45 /* Level 24 */
#define MTRAP_ELEC		0x46 /* Level 30 */
#define MTRAP_EXPLOSIVE	        0x47 /* Level 36 */
#define MTRAP_PORTAL	        0x48 /* Level 42 */
#define MTRAP_STASIS	        0x49 /* Level 48 */
#define MTRAP_DRAIN_LIFE	0x4A /* Level * */
#define MTRAP_UNMAGIC	        0x4B /* Level * */
#define MTRAP_DISPEL_M	        0x4C /* Level * */
#define MTRAP_GENOCIDE	        0x4D /* Level * */


/*** Artifact indexes (see "lib/edit/a_info.txt") ***/

#define ART_MORGOTH		51
#define ART_UNGOLIANT           74
#define ART_GROND		158




/*** Ego-Item indexes (see "lib/edit/e_info.txt") ***/


/* Nothing */
/* xxx */
/* xxx */
/* xxx */

/* Body Armor */
#define EGO_RESIST_ACID		4
#define EGO_RESIST_ELEC		5
#define EGO_RESIST_FIRE		6
#define EGO_RESIST_COLD		7
#define EGO_RESISTANCE		8
#define EGO_ELVENKIND		9
#define EGO_DWARVEN		10
#define EGO_PERMANENCE		11
/* xxx */
/* xxx */
/* xxx */
/* xxx */

/* Shields */
#define EGO_ENDURE_ACID		16
#define EGO_ENDURE_ELEC		17
#define EGO_ENDURE_FIRE		18
#define EGO_ENDURE_COLD		19
#define EGO_ENDURANCE		20
#define EGO_NIGHT_DAY		21	/* Added in Oangband. */
/* xxx */
/* xxx */

/* Crowns and Helms */
#define EGO_INTELLIGENCE	24
#define EGO_WISDOM		25
#define EGO_BEAUTY		26
#define EGO_MAGI		27
#define EGO_MIGHT		28
#define EGO_LORDLINESS		29
#define EGO_SEEING		30
#define EGO_SERENITY		31	/* Changed in Oangband. */
#define EGO_LIGHT		32
#define EGO_TELEPATHY		33
#define EGO_REGENERATION	34
#define EGO_TELEPORTATION	35
#define EGO_STUPIDITY		36
#define EGO_NAIVETY		37
#define EGO_UGLINESS		38
#define EGO_SICKLINESS		39

/* Cloaks */
#define EGO_PROTECTION		40
#define EGO_STEALTH		41
#define EGO_AMAN		42
/* xxx */
#define EGO_ENVELOPING		44
#define EGO_VULNERABILITY	45
#define EGO_IRRITATION		46
#define EGO_SHARD_PROT		47	/* Added in Oangband. */

/* Gloves */
#define EGO_FREE_ACTION		48
#define EGO_SLAYING		49
#define EGO_AGILITY		50
#define EGO_POWER		51
#define EGO_MAGIC_MASTERY	52	/* Added in Oangband. */
/* xxx */
#define EGO_WEAKNESS		54
#define EGO_CLUMSINESS		55

/* Boots */
#define EGO_SLOW_DESCENT	56
#define EGO_QUIET		57
#define EGO_MOTION		58
#define EGO_SPEED		59
#define EGO_STABILITY		60	/* Added in Oangband. */
#define EGO_NOISE		61
#define EGO_SLOWNESS		62
#define EGO_TORMENT		63

/* Weapons */
#define EGO_HA			64
#define EGO_DORIATH		65
#define EGO_BLESS_BLADE		66
#define EGO_GONDOLIN            67
#define EGO_NOLDOR		68
#define EGO_NOGROD              69
/* xxx */
/* xxx */
#define EGO_BRAND_ACID		72
#define EGO_BRAND_ELEC		73
#define EGO_BRAND_FIRE		74
#define EGO_BRAND_COLD		75
#define EGO_BRAND_POIS		76	/* Added in Oangband. */
#define EGO_BALROG		77	/* Added in Oangband. */
/* xxx */
/* xxx */
#define EGO_SLAY_ANIMAL		80
#define EGO_SLAY_EVIL		81
#define EGO_SLAY_UNDEAD		82
#define EGO_SLAY_DEMON		83
#define EGO_SLAY_ORC		84
#define EGO_SLAY_TROLL		85
#define EGO_SLAY_GIANT		86
#define EGO_SLAY_DRAGON		87
#define EGO_KILL_ANIMAL		88
#define EGO_KILL_EVIL		89
#define EGO_KILL_UNDEAD		90
#define EGO_KILL_DEMON		83
#define EGO_KILL_ORC		84
#define EGO_KILL_TROLL		85
#define EGO_KILL_GIANT		86
#define EGO_KILL_DRAGON		95
/* xxx */
/* xxx */
/* xxx */
/* xxx */
#define EGO_DIGGING		100
/* xxx */
#define EGO_ANGBAND		102
/* xxx */

/* Bows */
#define EGO_ACCURACY		104
#define EGO_VELOCITY		105
#define EGO_OSSIRIAND           106
#define EGO_EXTRA_MIGHT 	107
/* xxx */
#define EGO_EXTRA_SHOTS		109
/* xxx */
/* xxx */

/* Ammo */
#define EGO_HURT_ANIMAL		111
#define EGO_HURT_EVIL		112
#define EGO_HURT_UNDEAD		113
#define EGO_HURT_DEMON		114
#define EGO_HURT_ORC		115
#define EGO_HURT_TROLL		116
#define EGO_HURT_GIANT		117
#define EGO_HURT_DRAGON		118
#define EGO_ACIDIC		119	/* Added in Oangband. */
#define EGO_ELECT		120	/* Added in Oangband. */
#define EGO_FLAME		121
#define EGO_FROST		122
#define EGO_POISON		123	/* Added in Oangband. */
#define EGO_WOUNDING		124
#define EGO_BACKBITING		125

/* Rings */
#define EGO_RING_ELEMENTS       128
#define EGO_RING_PHYSICAL       129
#define EGO_RING_COMBAT         130
#define EGO_RING_MOBILITY       131
#define EGO_RING_ARCANE_RES     132
#define EGO_RING_UTILITY        133
#define EGO_RING_BASIC_RES      134
#define EGO_RING_HINDRANCE      135
#define EGO_RING_DAWN           136
#define EGO_RING_SPEED          137
#define EGO_RING_WOE            138
#define EGO_RING_FICKLENESS     139
#define EGO_RING_POWER          140

/* Amulets */

#define EGO_AMULET_MENTAL       160
#define EGO_AMULET_DOOM         161
#define EGO_AMULET_BASIC_RES    162
#define EGO_AMULET_MAGIC_MAST   163
#define EGO_AMULET_CLARITY      164
#define EGO_AMULET_SHADOWS      165
#define EGO_AMULET_METAMORPH    166
#define EGO_AMULET_SUSTENANCE   167
#define EGO_AMULET_TRICKERY     168
#define EGO_AMULET_WEAPONMAST   169
#define EGO_AMULET_VITALITY     170
#define EGO_AMULET_INSIGHT      171


/*** Squelch stuff ***/

/** Number of bytes used in squelch sub-quality array - probably unnecessary */
#define SQUELCH_BYTES    6


/*** Monster blow constants ***/


#define MONSTER_BLOW_MAX 4

/*
 * New monster blow methods
 */
#define RBM_HIT		1
#define RBM_TOUCH	2
#define RBM_PUNCH	3
#define RBM_KICK	4
#define RBM_CLAW	5
#define RBM_BITE	6
#define RBM_STING	7
#define RBM_XXX1	8
#define RBM_BUTT	9
#define RBM_CRUSH	10
#define RBM_ENGULF	11
#define RBM_XXX2	12
#define RBM_CRAWL	13
#define RBM_DROOL	14
#define RBM_SPIT	15
#define RBM_XXX3	16
#define RBM_GAZE	17
#define RBM_WAIL	18
#define RBM_SPORE	19
#define RBM_XXX4	20
#define RBM_BEG		21
#define RBM_INSULT	22
#define RBM_SNEER	23
#define RBM_REQUEST	24


/*
 * New monster blow effects
 */
#define RBE_HURT	1
#define RBE_POISON	2
#define RBE_UN_BONUS	3
#define RBE_UN_POWER	4
#define RBE_EAT_GOLD	5
#define RBE_EAT_ITEM	6
#define RBE_EAT_FOOD	7
#define RBE_EAT_LIGHT	8
#define RBE_ACID	9
#define RBE_ELEC	10
#define RBE_FIRE	11
#define RBE_COLD	12
#define RBE_BLIND	13
#define RBE_CONFUSE	14
#define RBE_TERRIFY	15
#define RBE_PARALYZE	16
#define RBE_LOSE_STR	17
#define RBE_LOSE_INT	18
#define RBE_LOSE_WIS	19
#define RBE_LOSE_DEX	20
#define RBE_LOSE_CON	21
#define RBE_LOSE_CHR	22
#define RBE_LOSE_ALL	23
#define RBE_SHATTER	24
#define RBE_EXP_10	25
#define RBE_EXP_20	26
#define RBE_EXP_40	27
#define RBE_EXP_80	28


/** 1/x chance of reducing stats (for elemental attacks).  From Zangband
 * -LM-
 */
#define HURT_CHANCE	25


/*** Function flags ***/


#define PROJECT_NO          0
#define PROJECT_NOT_CLEAR   1
#define PROJECT_CLEAR       2

/*
 * Bit flags for the "target_set" function
 *
 *	KILL: Target monsters
 *	LOOK: Describe grid fully
 *	OBJ : Target objects
 *	GRID: Select from all grids
 */
#define TARGET_KILL	0x01
#define TARGET_LOOK	0x02
#define TARGET_OBJ	0x04
#define TARGET_GRID	0x08
#define TARGET_QUIET    0x10


/*
 * Bit flags for the "monster_desc" function
 */
#define MDESC_OBJE	0x01	/* Objective (or Reflexive) */
#define MDESC_POSS	0x02	/* Possessive (or Reflexive) */
#define MDESC_IND1	0x04	/* Indefinites for hidden monsters */
#define MDESC_IND2	0x08	/* Indefinites for visible monsters */
#define MDESC_PRO1	0x10	/* Pronominalize hidden monsters */
#define MDESC_PRO2	0x20	/* Pronominalize visible monsters */
#define MDESC_HIDE	0x40	/* Assume the monster is hidden */
#define MDESC_SHOW	0x80	/* Assume the monster is visible */


/*
 * Bit flags for the "get_item" function
 */
#define USE_EQUIP	0x01	/* Allow equip items */
#define USE_INVEN	0x02	/* Allow inven items */
#define USE_FLOOR	0x04	/* Allow floor items */
#define USE_TARGET	0x08	/* Allow targeted floor items */
#define CAN_SQUELCH	0x10	/* Allow selection of all squelched items */
#define IS_HARMLESS     0x20	/* Ignore generic warning inscriptions */
#define SHOW_PRICES     0x40	/* Show item prices in item lists */
#define SHOW_FAIL       0x80 	/* Show device failure in item lists */
#define QUIVER_TAGS     0x100  /* 0-9 are quiver slots when selecting */

/*** Player flags ***/


/*
 * Bit flags for the "p_ptr->notice" variable
 */
#define PN_COMBINE	0x00000001L	/* Combine the pack */
#define PN_REORDER	0x00000002L	/* Reorder the pack */
#define PN_AUTOINSCRIBE	0x00000004L	/* Autoinscribe items */
#define PN_PICKUP       0x00000008L	/* Pick stuff up */
#define PN_SQUELCH      0x00000010L	/* Squelch stuff */
#define PN_SORT_QUIVER  0x00000020L     /* Sort the quiver */
/* xxx (many) */


/*
 * Bit flags for the "p_ptr->update" variable
 */
#define PU_BONUS	0x00000001L	/* Calculate bonuses */
#define PU_TORCH	0x00000002L	/* Calculate torch radius */
/* xxx (many) */
#define PU_HP		0x00000010L	/* Calculate chp and mhp */
#define PU_MANA		0x00000020L	/* Calculate csp and msp */
#define PU_SPELLS	0x00000040L	/* Calculate spells */
#define PU_SPECIALTY	0x00000080L	/* Calculate specialties */
/* xxx (many) */
#define PU_FORGET_VIEW	0x00010000L	/* Forget field of view */
#define PU_UPDATE_VIEW	0x00020000L	/* Update field of view */
/* xxx (many) */
#define PU_MONSTERS	0x10000000L	/* Update monsters */
#define PU_DISTANCE	0x20000000L	/* Update distances */
/* xxx */
#define PU_PANEL	0x80000000L	/* Update panel */


/*
 * Bit flags for the "p_ptr->redraw" variable
 */
#define PR_MISC		0x00000001L	/* Display Race/Class */
#define PR_TITLE	0x00000002L	/* Display Title */
#define PR_LEV		0x00000004L	/* Display Level */
#define PR_EXP		0x00000008L	/* Display Experience */
#define PR_STATS	0x00000010L	/* Display Stats */
#define PR_ARMOR	0x00000020L	/* Display Armor */
#define PR_HP		0x00000040L	/* Display Hitpoints */
#define PR_MANA		0x00000080L	/* Display Mana */
#define PR_GOLD		0x00000100L	/* Display Gold */
#define PR_DEPTH	0x00000200L	/* Display Depth */
#define PR_SHAPE	0x00000400L	/* Display Shape.  -LM- */
#define PR_HEALTH	0x00000800L	/* Display Health Bar */
#define PR_INVEN	0x00001000L /* Display inven/equip */
#define PR_EQUIP	0x00002000L /* Display equip/inven */
#define PR_MESSAGE	0x00004000L /* Display messages */
#define PR_MONSTER	0x00008000L /* Display monster recall */
#define PR_OBJECT	0x00010000L /* Display object recall */
#define PR_MONLIST	0x00020000L /* Display monster list */

#define PR_BUTTONS      0x00040000L     /* Display mouse buttons */
#define PR_ITEMLIST     0x00080000L /* Display item list */
#define PR_STATE	0x00100000L	/* Display Extra (State) */
#define PR_SPEED	0x00200000L	/* Display Extra (Speed) */
#define PR_STUDY	0x00400000L	/* Display Extra (Study) */
#define PR_DTRAP        0x00800000L     /* Display Extra (DTrap) */

#define PR_MON_MANA	0x04000000L	/* Display Mana Bar */
#define PR_MAP		0x08000000L	/* Display Map */
#define PR_WIPE         0x10000000L     /* Hack -- Total Redraw */

#define PR_STATUS	0x80000000L /* Display extra status messages */

/* Display Basic Info */
#define PR_BASIC \
	(PR_MISC | PR_TITLE | PR_STATS | PR_LEV |\
	 PR_EXP | PR_GOLD | PR_ARMOR | PR_HP |\
	 PR_MANA | PR_DEPTH | PR_HEALTH | PR_SPEED)

/* Display Extra Info */
#define PR_EXTRA \
	(PR_STATUS | PR_STATE | PR_STUDY)

/*
 * Bit flags for the "p_ptr->window" variable (etc)
 */
#define PW_INVEN	0x00000001L	/* Display inven/equip */
#define PW_EQUIP	0x00000002L	/* Display equip/inven */
#define PW_PLAYER_0	0x00000004L	/* Display player (basic) */
#define PW_PLAYER_1	0x00000008L	/* Display player (extra) */
#define PW_PLAYER_2     0x00000010L     /* Display player (compact) */
#define PW_MAP          0x00000020L     /* Display dungeon map */
#define PW_MESSAGE	0x00000040L	/* Display messages */
#define PW_OVERHEAD	0x00000080L	/* Display overhead view */
#define PW_MONSTER	0x00000100L	/* Display monster recall */
#define PW_OBJECT	0x00000200L	/* Display object recall */
#define PW_DUNGEON      0x00000400L     /* Display dungeon view */
#define PW_SNAPSHOT	0x00000800L	/* Display snap-shot */
#define PW_MONLIST      0x00001000L     /* Display monster list */
#define PW_ITEMLIST     0x00002000L     /* Display item list */
#define PW_BORG_1	0x00004000L	/* Display borg messages */
#define PW_BORG_2	0x00008000L	/* Display borg status */

#define PW_MAX_FLAGS		16

/*
 * Bit flags for the "p_ptr->special_attack" variable. -LM-
 *
 * Note:  The elemental and poison attacks should be managed using the 
 * function "set_ele_attack", in spell2.c.  This provides for timeouts and
 * prevents the player from getting more than one at a time.
 */
#define ATTACK_NORMAL           0x00000000
#define ATTACK_CONFUSE		0x00000001
#define ATTACK_BLKBRTH		0x00000002
#define ATTACK_FLEE		0x00000004
#define ATTACK_SUPERSHOT	0x00000008
#define ATTACK_ACID		0x00000010
#define ATTACK_ELEC		0x00000020
#define ATTACK_FIRE		0x00000040
#define ATTACK_COLD		0x00000080
#define ATTACK_POIS		0x00000100
#define ATTACK_HOLY		0x00000200

#define ATTACK_DRUID_CONFU	0x00010000

/* Special attack states that may be displayed on screen */
#define ATTACK_NOTICE		0x000003ff

/*
 * Values for shapechanges.  From Sangband.
 * As of FAangband 1.0.0 shapes must be consecutive
 */
#define SHAPE_NORMAL   0			/* Unaltered form. */
#define SHAPE_MOUSE    1
#define SHAPE_FERRET   2
#define SHAPE_HOUND    3
#define SHAPE_GAZELLE  4
#define SHAPE_LION     5
#define SHAPE_ENT      6
#define SHAPE_BAT      7
#define SHAPE_WEREWOLF 8
#define SHAPE_VAMPIRE  9
#define SHAPE_WYRM    10
#define SHAPE_BEAR    11
#define MAX_SHAPE     11

#define SCHANGE \
    (p_ptr->schange > 0 && p_ptr->schange < 12)



/*
 * Cave flags
 */

enum
{
	#define CAVE(a,b) CAVE_##a,
	#include "list-cave-flags.h"
	#undef CAVE
	CAVE_MAX
};

#define CAVE_SIZE                FLAG_SIZE(CAVE_MAX)

#define cave_has(f, flag)        flag_has_dbg(f, CAVE_SIZE, flag, #f, #flag)
#define cave_next(f, flag)       flag_next(f, CAVE_SIZE, flag)
#define cave_is_empty(f)         flag_is_empty(f, CAVE_SIZE)
#define cave_is_full(f)          flag_is_full(f, CAVE_SIZE)
#define cave_is_inter(f1, f2)    flag_is_inter(f1, f2, CAVE_SIZE)
#define cave_is_subset(f1, f2)   flag_is_subset(f1, f2, CAVE_SIZE)
#define cave_is_equal(f1, f2)    flag_is_equal(f1, f2, CAVE_SIZE)
#define cave_on(f, flag)         flag_on_dbg(f, CAVE_SIZE, flag, #f, #flag)
#define cave_off(f, flag)        flag_off(f, CAVE_SIZE, flag)
#define cave_wipe(f)             flag_wipe(f, CAVE_SIZE)
#define cave_setall(f)           flag_setall(f, CAVE_SIZE)
#define cave_negate(f)           flag_negate(f, CAVE_SIZE)
#define cave_copy(f1, f2)        flag_copy(f1, f2, CAVE_SIZE)
#define cave_union(f1, f2)       flag_union(f1, f2, CAVE_SIZE)
#define cave_comp_union(f1, f2)  flag_comp_union(f1, f2, CAVE_SIZE)
#define cave_inter(f1, f2)       flag_inter(f1, f2, CAVE_SIZE)
#define cave_diff(f1, f2)        flag_diff(f1, f2, CAVE_SIZE)

/*** Object flags ***/


/*
 * Chest trap flags (see "tables.c")
 */
#define CHEST_LOSE_STR		0x0001
#define CHEST_LOSE_CON		0x0002
#define CHEST_POISON		0x0004
#define CHEST_PARALYZE		0x0008
#define CHEST_EXPLODE		0x0010
#define CHEST_SUMMON		0x0020
#define CHEST_SCATTER		0x0040
#define CHEST_E_SUMMON		0x0080
#define CHEST_BIRD_STORM	0x0100
#define CHEST_H_SUMMON		0x0200
#define CHEST_RUNES_OF_EVIL	0x0400




/*
 * Special Object Flags
 */
#define IDENT_SENSE	  0x01	/* Item has been "sensed" */
#define IDENT_STORE	  0x02	/* Item is in the inventory of a store */
#define IDENT_EMPTY	  0x04	/* Item charges are known */
#define IDENT_KNOWN	  0x08	/* Item abilities are known */
#define IDENT_CURSED      0x10  /* Item is known to be cursed */
#define IDENT_UNCURSED    0x20  /* Item is known not to be cursed */
#define IDENT_KNOW_CURSES 0x40  /* Item curses are all known */
#define IDENT_WORN	  0x80	/* Item has been wielded or worn */

/*
 * Game-generated feelings.  Used for inscriptions.
 */
#define FEEL_NONE              0
#define FEEL_DUBIOUS_STRONG    1
#define FEEL_PERILOUS          2
#define FEEL_DUBIOUS_WEAK      3
#define FEEL_AVERAGE           4
#define FEEL_GOOD_STRONG       5
#define FEEL_EXCELLENT         6
#define FEEL_GOOD_WEAK         7
#define FEEL_SPECIAL           8
#define FEEL_MAX               9


/*
 * Some bit-flags for the "smart" field
 *
 * Most of these relate to OF_* object flags or P_RES_* and percentage resists
 */
#define SM_RES_STRONG_ACID	0x00000001
#define SM_RES_STRONG_ELEC	0x00000002
#define SM_RES_STRONG_FIRE	0x00000004
#define SM_RES_STRONG_COLD	0x00000008
#define SM_RES_STRONG_POIS	0x00000010
#define SM_XXX1		        0x00000020
#define SM_XXX2		        0x00000040
#define SM_XXX3		        0x00000080
#define SM_GOOD_SAVE		0x00000100
#define SM_PERF_SAVE		0x00000200
#define SM_IMM_FREE		0x00000400
#define SM_IMM_MANA		0x00000800
#define SM_IMM_ACID		0x00001000
#define SM_IMM_ELEC		0x00002000
#define SM_IMM_FIRE		0x00004000
#define SM_IMM_COLD		0x00008000
#define SM_RES_ACID		0x00010000
#define SM_RES_ELEC		0x00020000
#define SM_RES_FIRE		0x00040000
#define SM_RES_COLD		0x00080000
#define SM_RES_POIS		0x00100000
#define SM_RES_FEAR		0x00200000
#define SM_RES_LIGHT		0x00400000
#define SM_RES_DARK		0x00800000
#define SM_RES_BLIND	        0x01000000
#define SM_RES_CONFU	        0x02000000
#define SM_RES_SOUND	        0x04000000
#define SM_RES_SHARD	        0x08000000
#define SM_RES_NEXUS	        0x10000000
#define SM_RES_NETHR	        0x20000000
#define SM_RES_CHAOS	        0x40000000
#define SM_RES_DISEN	        0x80000000

/*
 * Object flags
 */

enum
{
	#define OF(a,b) OF_##a,
	#include "list-object-flags.h"
	#undef OF
	OF_MAX
};

#define OF_SIZE                FLAG_SIZE(OF_MAX)

#define of_has(f, flag)        flag_has_dbg(f, OF_SIZE, flag, #f, #flag)
#define of_next(f, flag)       flag_next(f, OF_SIZE, flag)
#define of_is_empty(f)         flag_is_empty(f, OF_SIZE)
#define of_is_full(f)          flag_is_full(f, OF_SIZE)
#define of_is_inter(f1, f2)    flag_is_inter(f1, f2, OF_SIZE)
#define of_is_subset(f1, f2)   flag_is_subset(f1, f2, OF_SIZE)
#define of_is_equal(f1, f2)    flag_is_equal(f1, f2, OF_SIZE)
#define of_on(f, flag)         flag_on_dbg(f, OF_SIZE, flag, #f, #flag)
#define of_off(f, flag)        flag_off(f, OF_SIZE, flag)
#define of_wipe(f)             flag_wipe(f, OF_SIZE)
#define of_setall(f)           flag_setall(f, OF_SIZE)
#define of_negate(f)           flag_negate(f, OF_SIZE)
#define of_copy(f1, f2)        flag_copy(f1, f2, OF_SIZE)
#define of_union(f1, f2)       flag_union(f1, f2, OF_SIZE)
#define of_comp_union(f1, f2)  flag_comp_union(f1, f2, OF_SIZE)
#define of_inter(f1, f2)       flag_inter(f1, f2, OF_SIZE)
#define of_diff(f1, f2)        flag_diff(f1, f2, OF_SIZE)

#define OF_OBVIOUS_MASK \
  OF_THROWING, OF_PERFECT_BALANCE, OF_TWO_HANDED_REQ,	\
    OF_TWO_HANDED_DES, OF_SHOW_MODS 

#define OF_PROOF_MASK \
  OF_ACID_PROOF, OF_ELEC_PROOF, OF_FIRE_PROOF,	OF_COLD_PROOF
 
/*
 * Curse flags
 */

enum
{
	#define CF(a,b) CF_##a,
	#include "list-curse-flags.h"
	#undef CF
	CF_MAX
};

#define CF_SIZE                FLAG_SIZE(CF_MAX)

#define cf_has(f, flag)        flag_has_dbg(f, CF_SIZE, flag, #f, #flag)
#define cf_next(f, flag)       flag_next(f, CF_SIZE, flag)
#define cf_is_empty(f)         flag_is_empty(f, CF_SIZE)
#define cf_is_full(f)          flag_is_full(f, CF_SIZE)
#define cf_is_inter(f1, f2)    flag_is_inter(f1, f2, CF_SIZE)
#define cf_is_subset(f1, f2)   flag_is_subset(f1, f2, CF_SIZE)
#define cf_is_equal(f1, f2)    flag_is_equal(f1, f2, CF_SIZE)
#define cf_on(f, flag)         flag_on_dbg(f, CF_SIZE, flag, #f, #flag)
#define cf_off(f, flag)        flag_off(f, CF_SIZE, flag)
#define cf_wipe(f)             flag_wipe(f, CF_SIZE)
#define cf_setall(f)           flag_setall(f, CF_SIZE)
#define cf_negate(f)           flag_negate(f, CF_SIZE)
#define cf_copy(f1, f2)        flag_copy(f1, f2, CF_SIZE)
#define cf_union(f1, f2)       flag_union(f1, f2, CF_SIZE)
#define cf_comp_union(f1, f2)  flag_comp_union(f1, f2, CF_SIZE)
#define cf_inter(f1, f2)       flag_inter(f1, f2, CF_SIZE)
#define cf_diff(f1, f2)        flag_diff(f1, f2, CF_SIZE)


/*
 * Kind flags
 */

enum
{
	#define KF(a,b) KF_##a,
	#include "list-kind-flags.h"
	#undef KF
	KF_MAX
};

#define KF_SIZE                FLAG_SIZE(KF_MAX)

#define kf_has(f, flag)        flag_has_dbg(f, KF_SIZE, flag, #f, #flag)
#define kf_next(f, flag)       flag_next(f, KF_SIZE, flag)
#define kf_is_empty(f)         flag_is_empty(f, KF_SIZE)
#define kf_is_full(f)          flag_is_full(f, KF_SIZE)
#define kf_is_inter(f1, f2)    flag_is_inter(f1, f2, KF_SIZE)
#define kf_is_subset(f1, f2)   flag_is_subset(f1, f2, KF_SIZE)
#define kf_is_equal(f1, f2)    flag_is_equal(f1, f2, KF_SIZE)
#define kf_on(f, flag)         flag_on_dbg(f, KF_SIZE, flag, #f, #flag)
#define kf_off(f, flag)        flag_off(f, KF_SIZE, flag)
#define kf_wipe(f)             flag_wipe(f, KF_SIZE)
#define kf_setall(f)           flag_setall(f, KF_SIZE)
#define kf_negate(f)           flag_negate(f, KF_SIZE)
#define kf_copy(f1, f2)        flag_copy(f1, f2, KF_SIZE)
#define kf_union(f1, f2)       flag_union(f1, f2, KF_SIZE)
#define kf_comp_union(f1, f2)  flag_comp_union(f1, f2, KF_SIZE)
#define kf_inter(f1, f2)       flag_inter(f1, f2, KF_SIZE)
#define kf_diff(f1, f2)        flag_diff(f1, f2, KF_SIZE)


/*
 * Identify flags
 */

enum
{
	#define IF(a,b) IF_##a,
	#include "list-identify-flags.h"
	#undef IF
	IF_MAX
};

#define IF_SIZE                FLAG_SIZE(IF_MAX)

#define if_has(f, flag)        flag_has_dbg(f, IF_SIZE, flag, #f, #flag)
#define if_next(f, flag)       flag_next(f, IF_SIZE, flag)
#define if_is_empty(f)         flag_is_empty(f, IF_SIZE)
#define if_is_full(f)          flag_is_full(f, IF_SIZE)
#define if_is_inter(f1, f2)    flag_is_inter(f1, f2, IF_SIZE)
#define if_is_subset(f1, f2)   flag_is_subset(f1, f2, IF_SIZE)
#define if_is_equal(f1, f2)    flag_is_equal(f1, f2, IF_SIZE)
#define if_on(f, flag)         flag_on_dbg(f, IF_SIZE, flag, #f, #flag)
#define if_off(f, flag)        flag_off(f, IF_SIZE, flag)
#define if_wipe(f)             flag_wipe(f, IF_SIZE)
#define if_setall(f)           flag_setall(f, IF_SIZE)
#define if_negate(f)           flag_negate(f, IF_SIZE)
#define if_copy(f1, f2)        flag_copy(f1, f2, IF_SIZE)
#define if_union(f1, f2)       flag_union(f1, f2, IF_SIZE)
#define if_comp_union(f1, f2)  flag_comp_union(f1, f2, IF_SIZE)
#define if_inter(f1, f2)       flag_inter(f1, f2, IF_SIZE)
#define if_diff(f1, f2)        flag_diff(f1, f2, IF_SIZE)




/*
 * Random object kind flag info (base flag value)
 */
#define OBJECT_RAND_BASE_SUSTAIN	OF_SUSTAIN_STR
#define OBJECT_RAND_BASE_POWER		OF_SLOW_DIGEST

/*
 * Random object kind flag info (number of flags)
 */
#define OBJECT_RAND_SIZE_SUSTAIN	6
#define OBJECT_RAND_SIZE_POWER		10

/* 
 * Object ID flag info (base flag value)
 */
#define OBJECT_ID_BASE_RESIST           IF_RES_ACID
#define OBJECT_ID_BASE_SLAY             IF_SLAY_ANIMAL
#define OBJECT_ID_BASE_BRAND            IF_BRAND_ACID

/*
 * Player race and class flags
 */

enum
{
#define PF(a, b, c, d) PF_##a
	#include "list-player-flags.h"
	#undef PF
	PF_MAX
};

#define PF_SIZE                FLAG_SIZE(PF_MAX)

enum
{
    PLAYER_FLAG_SPECIAL,
    PLAYER_FLAG_RACE,
    PLAYER_FLAG_CLASS
};

#define PF_NO_SPECIALTY		255


#define pf_has(f, flag)        flag_has_dbg(f, PF_SIZE, flag, #f, #flag)
#define pf_next(f, flag)       flag_next(f, PF_SIZE, flag)
#define pf_is_empty(f)         flag_is_empty(f, PF_SIZE)
#define pf_is_full(f)          flag_is_full(f, PF_SIZE)
#define pf_is_inter(f1, f2)    flag_is_inter(f1, f2, PF_SIZE)
#define pf_is_subset(f1, f2)   flag_is_subset(f1, f2, PF_SIZE)
#define pf_is_equal(f1, f2)    flag_is_equal(f1, f2, PF_SIZE)
#define pf_on(f, flag)         flag_on_dbg(f, PF_SIZE, flag, #f, #flag)
#define pf_off(f, flag)        flag_off(f, PF_SIZE, flag)
#define pf_wipe(f)             flag_wipe(f, PF_SIZE)
#define pf_setall(f)           flag_setall(f, PF_SIZE)
#define pf_negate(f)           flag_negate(f, PF_SIZE)
#define pf_copy(f1, f2)        flag_copy(f1, f2, PF_SIZE)
#define pf_union(f1, f2)       flag_union(f1, f2, PF_SIZE)
#define pf_comp_union(f1, f2)  flag_comp_union(f1, f2, PF_SIZE)
#define pf_inter(f1, f2)       flag_inter(f1, f2, PF_SIZE)
#define pf_diff(f1, f2)        flag_diff(f1, f2, PF_SIZE)

#define player_race_has(flag)        (pf_has(rp_ptr->pflags, (flag)))
#define player_class_has(flag)       (pf_has(cp_ptr->pflags, (flag)))
#define player_class_avail(flag)     (pf_has(cp_ptr->specialties, (flag)))
#define player_chose(flag)           (pf_has(p_ptr->pflags, (flag)))
#define player_has(flag)       (pf_has(rp_ptr->pflags, (flag)) || pf_has(cp_ptr->pflags, (flag)) || pf_has(p_ptr->pflags, (flag)))


/*** Terrain flags ***/

enum
{
	#define TF(a,b) TF_##a,
	#include "list-terrain-flags.h"
	#undef TF
	TF_MAX
};

#define TF_SIZE                FLAG_SIZE(TF_MAX)

#define tf_has(f, flag)        flag_has_dbg(f, TF_SIZE, flag, #f, #flag)


/*** Trap flags ***/

enum
{
	#define TRF(a,b) TRF_##a,
	#include "list-trap-flags.h"
	#undef TRF
	TRF_MAX
};

#define TRF_SIZE                FLAG_SIZE(TRF_MAX)

#define trf_has(f, flag)        flag_has_dbg(f, TRF_SIZE, flag, #f, #flag)
#define trf_next(f, flag)       flag_next(f, TRF_SIZE, flag)
#define trf_is_empty(f)         flag_is_empty(f, TRF_SIZE)
#define trf_is_full(f)          flag_is_full(f, TRF_SIZE)
#define trf_is_inter(f1, f2)    flag_is_inter(f1, f2, TRF_SIZE)
#define trf_is_subset(f1, f2)   flag_is_subset(f1, f2, TRF_SIZE)
#define trf_is_equal(f1, f2)    flag_is_equal(f1, f2, TRF_SIZE)
#define trf_on(f, flag)         flag_on_dbg(f, TRF_SIZE, flag, #f, #flag)
#define trf_off(f, flag)        flag_off(f, TRF_SIZE, flag)
#define trf_wipe(f)             flag_wipe(f, TRF_SIZE)
#define trf_setall(f)           flag_setall(f, TRF_SIZE)
#define trf_negate(f)           flag_negate(f, TRF_SIZE)
#define trf_copy(f1, f2)        flag_copy(f1, f2, TRF_SIZE)
#define trf_union(f1, f2)       flag_union(f1, f2, TRF_SIZE)
#define trf_comp_union(f1, f2)  flag_comp_union(f1, f2, TRF_SIZE)
#define trf_inter(f1, f2)       flag_inter(f1, f2, TRF_SIZE)
#define trf_diff(f1, f2)        flag_diff(f1, f2, TRF_SIZE)


/*** Monster flags ***/


/*
 * Special Monster Flags (all temporary)
 */
#define MFLAG_VIEW	0x01	/* Monster is in line of sight */
#define MFLAG_XXX1	0x02	/*  */
#define MFLAG_XXX2	0x04	/*  */
#define MFLAG_ACTV	0x08	/* Monster is in active mode */
#define MFLAG_WARY	0x10	/* Monster is wary of traps */
#define MFLAG_XXX5	0x20	/*  */
#define MFLAG_SHOW	0x40	/* Monster is recently memorized */
#define MFLAG_MARK	0x80	/* Monster is currently memorized */

enum
{
	#define RF(a,b) RF_##a,
	#include "list-mon-flags.h"
	#undef RF
	RF_MAX
};

#define RF_SIZE                FLAG_SIZE(RF_MAX)

#define rf_has(f, flag)        flag_has_dbg(f, RF_SIZE, flag, #f, #flag)
#define rf_next(f, flag)       flag_next(f, RF_SIZE, flag)
#define rf_is_empty(f)         flag_is_empty(f, RF_SIZE)
#define rf_is_full(f)          flag_is_full(f, RF_SIZE)
#define rf_is_inter(f1, f2)    flag_is_inter(f1, f2, RF_SIZE)
#define rf_is_subset(f1, f2)   flag_is_subset(f1, f2, RF_SIZE)
#define rf_is_equal(f1, f2)    flag_is_equal(f1, f2, RF_SIZE)
#define rf_on(f, flag)         flag_on_dbg(f, RF_SIZE, flag, #f, #flag)
#define rf_off(f, flag)        flag_off(f, RF_SIZE, flag)
#define rf_wipe(f)             flag_wipe(f, RF_SIZE)
#define rf_setall(f)           flag_setall(f, RF_SIZE)
#define rf_negate(f)           flag_negate(f, RF_SIZE)
#define rf_copy(f1, f2)        flag_copy(f1, f2, RF_SIZE)
#define rf_union(f1, f2)       flag_union(f1, f2, RF_SIZE)
#define rf_comp_union(f1, f2)  flag_comp_union(f1, f2, RF_SIZE)
#define rf_inter(f1, f2)       flag_inter(f1, f2, RF_SIZE)
#define rf_diff(f1, f2)        flag_diff(f1, f2, RF_SIZE)

/* Some flags are obvious */
#define RF_OBVIOUS_MASK \
	RF_UNIQUE, RF_QUESTOR, RF_MALE, RF_FEMALE, \
	RF_FRIEND, RF_FRIENDS, RF_ESCORT, RF_ESCORTS

/* "race" flags */
#define RF_RACE_MASK \
	RF_ORC, RF_TROLL, RF_GIANT, RF_DRAGON, \
	RF_DEMON, RF_UNDEAD, RF_EVIL, RF_ANIMAL, RF_METAL



/*
 * Monster spell flags
 */

enum
{
	#define RSF(a,b) RSF_##a,
	#include "list-mon-spells.h"
	#undef RSF
	RSF_MAX
};

#define RSF_SIZE               FLAG_SIZE(RSF_MAX)

#define rsf_has(f, flag)       flag_has_dbg(f, RSF_SIZE, flag, #f, #flag)
#define rsf_next(f, flag)      flag_next(f, RSF_SIZE, flag)
#define rsf_is_empty(f)        flag_is_empty(f, RSF_SIZE)
#define rsf_is_full(f)         flag_is_full(f, RSF_SIZE)
#define rsf_is_inter(f1, f2)   flag_is_inter(f1, f2, RSF_SIZE)
#define rsf_is_subset(f1, f2)  flag_is_subset(f1, f2, RSF_SIZE)
#define rsf_is_equal(f1, f2)   flag_is_equal(f1, f2, RSF_SIZE)
#define rsf_on(f, flag)        flag_on_dbg(f, RSF_SIZE, flag, #f, #flag)
#define rsf_off(f, flag)       flag_off(f, RSF_SIZE, flag)
#define rsf_wipe(f)            flag_wipe(f, RSF_SIZE)
#define rsf_setall(f)          flag_setall(f, RSF_SIZE)
#define rsf_negate(f)          flag_negate(f, RSF_SIZE)
#define rsf_copy(f1, f2)       flag_copy(f1, f2, RSF_SIZE)
#define rsf_union(f1, f2)      flag_union(f1, f2, RSF_SIZE)
#define rsf_comp_union(f1, f2) flag_comp_union(f1, f2, RSF_SIZE)
#define rsf_inter(f1, f2)      flag_inter(f1, f2, RSF_SIZE)
#define rsf_diff(f1, f2)       flag_diff(f1, f2, RSF_SIZE)

/**
 * Summons
 * Needed for shapechanging
 */
#define RSF_SUMMON_MASK \
    RSF_S_KIN, RSF_S_MONSTER, RSF_S_MONSTERS, RSF_S_ANT, RSF_S_SPIDER, \
	RSF_S_HOUND, RSF_S_ANIMAL, RSF_S_THIEF, RSF_S_SWAMP, RSF_S_DRAGON, \
	RSF_S_HI_DRAGON, RSF_S_DEMON, RSF_S_HI_DEMON, RSF_S_APPROP, \
	RSF_S_UNDEAD, RSF_S_HI_UNDEAD, RSF_S_QUEST, RSF_S_UNIQUE

/**
 * Breath attacks.
 * Need special treatment in movement AI.
 */
#define RSF_BREATH_MASK \
        RSF_BRTH_ACID, RSF_BRTH_ELEC, RSF_BRTH_FIRE, RSF_BRTH_COLD, \
         RSF_BRTH_POIS, RSF_BRTH_PLAS, RSF_BRTH_LIGHT, RSF_BRTH_DARK, \
         RSF_BRTH_CONFU, RSF_BRTH_SOUND, RSF_BRTH_SHARD, RSF_BRTH_INER, \
         RSF_BRTH_GRAV, RSF_BRTH_FORCE, RSF_BRTH_NEXUS, RSF_BRTH_NETHR, \
         RSF_BRTH_CHAOS, RSF_BRTH_DISEN, RSF_BRTH_TIME, RSF_BRTH_STORM, \
	 RSF_BRTH_DFIRE, RSF_BRTH_ICE, RSF_BRTH_ALL 

/**
 * Harassment (not direct damage) attacks.
 * Need special treatment in AI.
 */
#define RSF_HARASS_MASK \
	RSF_DARKNESS, RSF_TRAPS, RSF_FORGET, RSF_HUNGER, RSF_DRAIN_MANA, \
	  RSF_SCARE, RSF_BLIND, RSF_CONF, RSF_SLOW, RSF_HOLD, RSF_DISPEL

/* Number of times harassment spells get special treatment */
#define BASE_HARASS 5

/* Number of times harassment spells get special treatment from 
 * weaker creatures */
#define LOW_HARASS 2

/**
 * Hack -- "bolt" spells that may hurt fellow monsters
 * Need special treatment in AI.
 */
#define RSF_BOLT_MASK \
  RSF_ARROW, RSF_BOLT, RSF_SHOT, RSF_MISSL, RSF_PMISSL, RSF_BOULDER,	\
    RSF_BOLT_ACID, RSF_BOLT_ELEC, RSF_BOLT_FIRE, RSF_BOLT_COLD,		\
    RSF_BOLT_POIS, RSF_BOLT_NETHR, RSF_BOLT_WATER, RSF_BOLT_DARK,	\
    RSF_BOLT_PLAS, RSF_BOLT_ICE

/**
 * Archery attacks
 * Need special treatment in AI.
 */
#define RSF_ARCHERY_MASK \
  RSF_ARROW, RSF_BOLT, RSF_SHOT, RSF_MISSL, RSF_PMISSL, RSF_BOULDER

/**
 * Spells that can be can without a player in sight
 * Need special treatment in AI.
 */
#define RSF_NO_PLAYER_MASK \
  RSF_HEAL, RSF_ADD_MANA, RSF_TELE_SELF_TO, RSF_CURE


/* Spell Desire Table Columns */
#define D_BASE     0
#define D_SUMM     1
#define D_HURT     2
#define D_MANA     3
#define D_ESC      4
#define D_TACT     5
#define D_RES      6
#define D_RANGE    7
#define D_MAX      8



/*** Macro Definitions ***/


/**
 * Hack -- The main "screen"
 */
#define term_screen	(angband_term[0])

/**
 * Determine if a given inventory item is "aware"
 */
#define object_aware_p(T) \
	(k_info[(T)->k_idx].aware)

/**
 * Determine if a given inventory item is "tried"
 */
#define object_tried_p(T) \
	(k_info[(T)->k_idx].tried)


/**
 * Determine if a given inventory item is "known"
 * Test One -- Check for special "known" tag
 * Test Two -- Check for "Easy Know" + "Aware"
 */
#define object_known_p(T) \
	(((T)->ident & (IDENT_KNOWN)) || \
	 (kf_has(k_info[(T)->k_idx].flags_kind, KF_EASY_KNOW) \
	  && k_info[(T)->k_idx].aware))

#define object_is_known object_known_p

/**
 * Object is a missile
 */
#define is_missile(T) \
	(((T)->tval == TV_SHOT)   || \
	 ((T)->tval == TV_ARROW)  || \
	 ((T)->tval == TV_BOLT))

/**
 * Object is armour
 */
#define is_weapon(T) \
  (((T)->tval >= TV_SHOT) && ((T)->tval <= TV_SWORD))

/**
 * Object is armour
 */
#define is_armour(T) \
  (((T)->tval >= TV_BOOTS) && ((T)->tval <= TV_DRAG_ARMOR))

/**
 * Object is a ring or amulet
 */
#define is_jewellery(T) \
  (((T)->tval >= TV_AMULET) && ((T)->tval <= TV_RING))

/**
 * Determine if the attr and char should consider the item's flavor
 *
 * Identified scrolls should use their own tile.
 */
#define use_flavor_glyph(K) \
	((k_info[(K)].flavor) && \
	 !((k_info[(K)].tval == TV_SCROLL) && k_info[(K)].aware))


/**
 * Return the "attr" for a given item kind.
 * Use "flavor" if available.
 * Default to user definitions.
 */
#define object_kind_attr(K) \
	(use_flavor_glyph(K) ? \
	 (flavor_info[k_info[(K)].flavor].x_attr) : \
	 (k_info[(K)].x_attr))

/**
 * Return the "char" for a given item kind.
 * Use "flavor" if available.
 * Default to user definitions.
 */
#define object_kind_char(K) \
	(use_flavor_glyph(K) ? \
	 (flavor_info[k_info[(K)].flavor].x_char) : \
	 (k_info[(K)].x_char))

/**
 * Return the "attr" for a given item.
 * Use "flavor" if available.
 * Default to user definitions.
 */
#define object_attr(T) \
	(object_kind_attr((T)->k_idx))

/**
 * Return the "char" for a given item.
 * Use "flavor" if available.
 * Default to user definitions.
 */
#define object_char(T) \
	(object_kind_char((T)->k_idx))


/**
 * Return the "attr" for a given item.
 * Use "flavor" if available.
 * Use default definitions.
 */
#define object_attr_default(T) \
	((k_info[(T)->k_idx].flavor) ? \
	 (flavor_info[k_info[(T)->k_idx].flavor].d_attr) : \
	 (k_info[(T)->k_idx].d_attr))

/**
 * Return the "char" for a given item.
 * Use "flavor" if available.
 * Use default definitions.
 */
#define object_char_default(T) \
	((k_info[(T)->k_idx].flavor) ? \
	 (flavor_info[k_info[(T)->k_idx].flavor].d_char) : \
	 (k_info[(T)->k_idx].d_char))

/**
 * Artifacts use the "name1" field
 */
#define artifact_p(T) \
	((T)->name1 ? TRUE : FALSE)

/**
 * Ego-Items use the "name2" field
 */
#define ego_item_p(T) \
	((T)->name2 ? TRUE : FALSE)

/**
 * Cursed items.
 */
#define cursed_p(T) \
    (!cf_is_empty((T)->flags_curse) ? TRUE : FALSE)

/**
 * Known cursed items.
 */
#define known_cursed_p(T) \
    (!(cf_is_empty((T)->id_curse)) || ((T)->ident & IDENT_CURSED) ? TRUE : FALSE)


/**
 * Some monster types are different.
 */
#define monster_is_unusual(R) \
	(flags_test((R)->flags, RF_SIZE, RF_DEMON, RF_UNDEAD, RF_STUPID, FLAG_END) || \
	strchr("Evg", (R)->d_char))

/**
 * Convert an "attr"/"char" pair into a "pict" (P)
 */
#define PICT(A,C) \
	((((u16b)(A)) << 8) | ((byte)(C)))

/**
 * Convert a "pict" (P) into an "attr" (A)
 */
#define PICT_A(P) \
	((byte)((P) >> 8))

/**
 * Convert a "pict" (P) into an "char" (C)
 */
#define PICT_C(P) \
	((char)((byte)(P)))


/**
 * Convert a "location" (Y,X) into a "grid" (G)
 */
#define GRID(Y,X) \
	(256 * (Y) + (X))

/**
 * Convert a "grid" (G) into a "location" (Y)
 */
#define GRID_Y(G) \
	((int)((G) / 256U))

/**
 * Convert a "grid" (G) into a "location" (X)
 */
#define GRID_X(G) \
	((int)((G) % 256U))


/**
 * Convert a "key event" into a "location" (Y)
 */
#define KEY_GRID_Y(K) \
  ((int) (((K.mouse.y - ROW_MAP) / tile_height) + Term->offset_y))

/**
 * Convert a "key event" into a "location" (X)
 */
#define KEY_GRID_X(K) \
	((int) (((K.mouse.x - COL_MAP) / tile_width) + Term->offset_x))

/**
 * Determines if a map location is "meaningful"
 */
#define in_bounds(Y,X) \
	(((unsigned)(Y) < (unsigned)(DUNGEON_HGT)) && \
	 ((unsigned)(X) < (unsigned)(DUNGEON_WID)))

/**
 * Determines if a map location is fully inside the outer walls
 * This is more than twice as expensive as "in_bounds()", but
 * often we need to exclude the outer walls from calculations.
 */
#define in_bounds_fully(Y,X) \
	(((Y) > 0) && ((Y) < DUNGEON_HGT-1) && \
	 ((X) > 0) && ((X) < DUNGEON_WID-1))


/**
 * Determines if a map location is currently "on screen"
 * Note that "panel_contains(Y,X)" always implies "in_bounds(Y,X)".
 * Pre-storing this into a cave_info flag would be nice.  XXX XXX
#define panel_contains(Y,X) \
	(((unsigned)((Y) - Term->offset_y) < (unsigned)(SCREEN_HGT)) && \
	 ((unsigned)((X) - Term->offset_x) < (unsigned)(SCREEN_WID)))
 */

/**
 * Determine if a legal grid can be projected through
 * This is a pretty feeble hack -NRM-
 */
#define cave_project(Y,X) \
    (tf_has(f_info[cave_feat[Y][X]].flags, TF_PROJECT)) 


/**
 * Determine if a legal grid is a clean floor grid
 * Used for placing objects
 *
 * Line 1 -- check can hold an object
 * Line 2 -- forbid normal objects
 */
#define cave_clean_bold(Y,X)		     \
    (tf_has(f_info[cave_feat[Y][X]].flags, TF_OBJECT) && \
     (cave_o_idx[Y][X] == 0))

/**
 * Determine if a legal grid is an empty floor grid
 * Used for safely placing the player or a monster
 *
 * Line 1 -- check easily passed through
 * Line 2 -- forbid player/monsters
 */
#define cave_empty_bold(Y,X) \
    (tf_has(f_info[cave_feat[Y][X]].flags, TF_EASY) && \
     (cave_m_idx[Y][X] == 0))

/**
 * Determine if a "legal" grid is within "los" of the player
 *
 * Note the use of comparison to zero to force a "boolean" result
 */
#define player_has_los_bold(Y,X) \
    (cave_has(cave_info[Y][X], CAVE_VIEW))


/**
 * Determine if a "legal" grid can be "seen" by the player
 *
 * Note the use of comparison to zero to force a "boolean" result
 */
#define player_can_see_bold(Y,X) \
    (cave_has(cave_info[Y][X], CAVE_SEEN))


/**
 * Is the player outside?
 */
#define outside \
    ((stage_map[p_ptr->stage][STAGE_TYPE] != CAVE)	\
     && (stage_map[p_ptr->stage][STAGE_TYPE] != VALLEY) \
       && ((p_ptr->stage < KHAZAD_DUM_TOWN) || (p_ptr->stage > MENEGROTH_TOWN)))

			 
/**
 * Is the player in daylight?
 */
#define is_daylight  (((turn % (10L * TOWN_DAWN)) < ((10L * TOWN_DAWN) / 2)) \
			&& outside) 


/*
 * Hack -- Prepare to use the "Secure" routines
 */
#if defined(SET_UID) && defined(SECURE)
extern int PlayerUID;
# define getuid() PlayerUID
# define geteuid() PlayerUID
#endif



/*** Hack ***/

/*
 * Maximum number of macro trigger names
 */
#define MAX_MACRO_TRIGGER 200
#define MAX_MACRO_MOD 12



/**
 * Max number of terminal windows -CN-
 */
#define TERM_WIN_MAX 8

/**
 * Max number of lines of notes
 */
#define DUMP_MAX_LINES 5000

/** Number of localities */

#define MAX_LOCALITIES 37


/* Localities -NRM- */

#define NOWHERE                0
#define HITHAEGLIR             1
#define ERIADOR                2
#define ERED_LUIN              3
#define ERED_LUIN_SOUTH        4
#define OSSIRIAND              5
#define TAUR_IM_DUINATH        6
#define EAST_BELERIAND         7
#define ANDRAM                 8
#define WEST_BELERIAND         9
#define THARGELION             10
#define DORIATH                11
#define HIMLAD                 12
#define DOR_DINEN              13
#define DORTHONION             14
#define TALATH_DIRNEN          15
#define BRETHIL                16
#define SIRION_VALE            17
#define FEN_OF_SERECH          18
#define ANFAUGLITH             19
#define LOTHLANN               20
#define AMON_RUDH              21
#define NAN_DUNGORTHEB         22
#define NARGOTHROND            23
#define TOL_IN_GAURHOTH        24
#define ANGBAND                25
#define ANDUIN_VALE            26
#define GLADDEN_FIELDS         27
#define KHAZAD_DUM             28
#define BELEGOST               29
#define MENEGROTH              30
#define EPHEL_BRANDIR          31
#define GONDOLIN               32
#define ENT_PATH               33
#define ERIADOR_SOUTH          34
#define UNDERWORLD             35
#define MOUNTAIN_TOP           36

/** Number of stage types */

#define NUM_STAGE_TYPES 10

/* types of stage -NRM- */

#define TOWN                   0
#define PLAIN                  1
#define FOREST                 2
#define MOUNTAIN               3  
#define SWAMP                  4
#define RIVER                  5
#define DESERT                 6
#define CAVE                   7
#define VALLEY                 8
#define MOUNTAINTOP            9

/* Fields for stage_map array */
#define LOCALITY               0
#define DEPTH                  1
#define NORTH                  2
#define EAST                   3
#define SOUTH                  4
#define WEST                   5
#define UP                     6
#define DOWN                   7
#define STAGE_TYPE             8

/* Special stage numbers */
#define ERIADOR_TOWN           (p_ptr->map == MAP_COMPRESSED ? 5 : 6)
#define OSSIRIAND_TOWN         (p_ptr->map == MAP_COMPRESSED ? 20 : 30)
#define ERED_LUIN_SOUTH_TOWN   (p_ptr->map == MAP_COMPRESSED ? 24 : 37)
#define TAUR_IM_DUINATH_TOWN   (p_ptr->map == MAP_COMPRESSED ? 27 : 44)
#define EPHEL_BRANDIR_TOWN     (p_ptr->map == MAP_COMPRESSED ? 59 : 115)
#define GLADDEN_FIELDS_TOWN    (p_ptr->map == MAP_COMPRESSED ? 79 : 150)
#define KHAZAD_DUM_TOWN        (p_ptr->map == MAP_COMPRESSED ? 80 : 151)
#define BELEGOST_TOWN          (p_ptr->map == MAP_COMPRESSED ? 81 : 152)
#define MENEGROTH_TOWN         (p_ptr->map == MAP_COMPRESSED ? 82 : 153)
#define GONDOLIN_TOWN          (p_ptr->map == MAP_COMPRESSED ? 83 : 154)
#define UNDERWORLD_STAGE       (p_ptr->map == MAP_COMPRESSED ? 84 : 255)
#define MOUNTAINTOP_STAGE      (p_ptr->map == MAP_COMPRESSED ? 85 : 256)


/*
 * Mouse click region names
 */
#define MOUSE_NULL    0
#define MOUSE_MAP     1
#define MOUSE_CHAR    2
#define MOUSE_HP      3
#define MOUSE_SP      4
#define MOUSE_STUDY   5
#define MOUSE_MESSAGE 6
#define MOUSE_PLACE   7
#define MOUSE_OBJECTS 8
#define MOUSE_STAND   9
#define MOUSE_REPEAT 10
#define MOUSE_RETURN 11
#define MOUSE_ESCAPE 12

#define SCAN_INSTANT ((u32b) -1)
#define SCAN_OFF 0
#define SCAN_MACRO 45


/**
 * Sign of a non-racial monster
 */
#define NON_RACIAL 255

/*
 * Rune types
#define RUNE_ELEMENTS   0
#define RUNE_MAGDEF     1
#define RUNE_QUAKE      2
#define RUNE_MANA       3
#define RUNE_PROTECT    4
#define RUNE_POWER      5
#define RUNE_SPEED      6
#define MAX_RUNE        7
 */

/** 
 * Maximum rune mana reserve 
 */
#define MAX_MANA_RESERVE 200

/** Max number of items in the itemlist */
#define MAX_ITEMLIST 256

/* MSVC doesn't have va_copy (which is C99) or an alternative, so we'll just
 * copy the SRC pointer. In other cases we'll use va_copy() as we should. */
#ifdef _MSC_VER
#define VA_COPY(DST, SRC) (DST) = (SRC)
#else
#define VA_COPY(DST, SRC) va_copy(DST, SRC)
#endif

#endif /* !INCLUDED_DEFINES_H */
